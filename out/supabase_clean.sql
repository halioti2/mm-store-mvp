-- Clean Public Schema for Supabase
-- Generated: 2026-02-06T02:47:42.677Z
-- Contains only public schema tables, functions, and data

-- Set basic configuration
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;

-- Name: products; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products (
    id bigint NOT NULL,
    name text NOT NULL,
    image_url text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    price real
);


ALTER TABLE public.products OWNER TO postgres;

--
-- Name: get_random_products(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_random_products(limit_count integer) RETURNS SETOF public.products
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT * FROM public.products
  ORDER BY random()
  LIMIT limit_count;
END;
$$;


ALTER FUNCTION public.get_random_products(limit_count integer) OWNER TO postgres;

--
-- Name: upsert_cart_item(uuid, bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upsert_cart_item(p_user_id uuid, p_product_id bigint, p_quantity_to_add integer) RETURNS TABLE(id bigint, user_id uuid, product_id bigint, quantity integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  INSERT INTO public.cart_items (user_id, product_id, quantity)
  VALUES (p_user_id, p_product_id, p_quantity_to_add)

  -- ðŸ‘‡ THE DEFINITIVE FIX IS HERE ðŸ‘‡
  -- Instead of listing the columns, we tell it the exact name of the unique constraint to watch.
  ON CONFLICT ON CONSTRAINT cart_items_user_id_product_id_key

  DO UPDATE
    -- The rest of the update logic remains the same, ensuring we update the correct row.
    SET quantity = cart_items.quantity + p_quantity_to_add
    WHERE cart_items.user_id = p_user_id AND cart_items.product_id = p_product_id

  -- The RETURNING clause remains the same.
  RETURNING cart_items.id, cart_items.user_id, cart_items.product_id, cart_items.quantity;
END;
$$;


ALTER FUNCTION public.upsert_cart_item(p_user_id uuid, p_product_id bigint, p_quantity_to_add integer) OWNER TO postgres;

--
-- Name: upsert_fridge_item(uuid, bigint, real); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upsert_fridge_item(p_user_id uuid, p_product_id bigint, p_quantity_to_add real) RETURNS TABLE(id bigint, user_id uuid, product_id bigint, quantity real)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  INSERT INTO public.fridge_items (user_id, product_id, quantity)
  VALUES (p_user_id, p_product_id, p_quantity_to_add)
  -- If a row with this user_id and product_id already exists...
  ON CONFLICT ON CONSTRAINT fridge_items_user_id_product_id_key
  -- ...then UPDATE the existing row instead.
  DO UPDATE
    SET quantity = fridge_items.quantity + p_quantity_to_add
  -- Finally, return the contents of the row that was just inserted or updated.
  RETURNING fridge_items.id, fridge_items.user_id, fridge_items.product_id, fridge_items.quantity;
END;
$$;


ALTER FUNCTION public.upsert_fridge_item(p_user_id uuid, p_product_id bigint, p_quantity_to_add real) OWNER TO postgres;

--
-- Name: cart_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cart_items (
    id bigint NOT NULL,
    user_id uuid NOT NULL,
    product_id bigint NOT NULL,
    quantity integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.cart_items OWNER TO postgres;

--
-- Name: cart_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.cart_items ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.cart_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: fridge_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fridge_items (
    id bigint NOT NULL,
    user_id uuid NOT NULL,
    product_id bigint NOT NULL,
    quantity real DEFAULT 1 NOT NULL
);


ALTER TABLE public.fridge_items OWNER TO postgres;

--
-- Name: fridge_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.fridge_items ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.fridge_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: meal_plan_recipes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.meal_plan_recipes (
    id bigint NOT NULL,
    recipe_id bigint NOT NULL,
    plan_date date DEFAULT CURRENT_DATE NOT NULL
);


ALTER TABLE public.meal_plan_recipes OWNER TO postgres;

--
-- Name: meal_plan_recipes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.meal_plan_recipes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.meal_plan_recipes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_tags; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_tags (
    product_id bigint NOT NULL,
    tag_id bigint NOT NULL
);


ALTER TABLE public.product_tags OWNER TO postgres;

--
-- Name: products_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.products ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.products_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: recipe_ingredients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.recipe_ingredients (
    id bigint NOT NULL,
    recipe_id bigint NOT NULL,
    product_id bigint NOT NULL,
    quantity real,
    unit text
);


ALTER TABLE public.recipe_ingredients OWNER TO postgres;

--
-- Name: recipe_ingredients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.recipe_ingredients ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.recipe_ingredients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: recipes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.recipes (
    id bigint NOT NULL,
    name text NOT NULL,
    instructions text[],
    image_url text,
    source_url text,
    prep_time_minutes integer,
    cook_time_minutes integer,
    servings integer,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.recipes OWNER TO postgres;

--
-- Name: recipes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.recipes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.recipes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: tags; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tags (
    id bigint NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    slug text
);


ALTER TABLE public.tags OWNER TO postgres;

--
-- Name: tags_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.tags ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.tags_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: unmatched_ingredients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.unmatched_ingredients (
    id bigint NOT NULL,
    normalized_attempt text NOT NULL,
    source_recipe_id bigint,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.unmatched_ingredients OWNER TO postgres;

--
-- Name: unmatched_ingredients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.unmatched_ingredients ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.unmatched_ingredients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: user_favorite_recipes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_favorite_recipes (
    user_id uuid NOT NULL,
    recipe_id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.user_favorite_recipes OWNER TO postgres;

--